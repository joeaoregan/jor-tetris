{"ast":null,"code":"import { COLS, BLOCK_SIZE, ROWS, COLORS, LINES_PER_LEVEL, LEVEL, POINTS, KEY } from '../constants';\nimport { Piece } from '../piece.component';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../game.service\";\nconst _c0 = [\"board\"];\nconst _c1 = [\"next\"];\nexport let BoardComponent = /*#__PURE__*/(() => {\n  class BoardComponent {\n    keyEvent(event) {\n      if (event.keyCode === KEY.ESC) {\n        this.gameOver();\n      } else if (this.moves[event.keyCode]) {\n        event.preventDefault();\n        // Get new state\n        let p = this.moves[event.keyCode](this.piece);\n        if (event.keyCode === KEY.SPACE) {\n          // Hard drop\n          while (this.service.valid(p, this.board)) {\n            this.points += POINTS.HARD_DROP;\n            this.piece.move(p);\n            p = this.moves[KEY.DOWN](this.piece);\n          }\n        } else if (this.service.valid(p, this.board)) {\n          this.piece.move(p);\n          if (event.keyCode === KEY.DOWN) {\n            this.points += POINTS.SOFT_DROP;\n          }\n        }\n      }\n    }\n    constructor(service) {\n      this.service = service;\n      this.moves = {\n        [KEY.LEFT]: p => ({\n          ...p,\n          x: p.x - 1\n        }),\n        [KEY.RIGHT]: p => ({\n          ...p,\n          x: p.x + 1\n        }),\n        [KEY.DOWN]: p => ({\n          ...p,\n          y: p.y + 1\n        }),\n        [KEY.SPACE]: p => ({\n          ...p,\n          y: p.y + 1\n        }),\n        [KEY.UP]: p => this.service.rotate(p)\n      };\n    }\n    ngOnInit() {\n      this.initBoard();\n      this.initNext();\n      this.resetGame();\n    }\n    initBoard() {\n      this.ctx = this.canvas.nativeElement.getContext('2d');\n      // Calculate size of canvas from constants.\n      this.ctx.canvas.width = COLS * BLOCK_SIZE;\n      this.ctx.canvas.height = ROWS * BLOCK_SIZE;\n      // Scale so we don't need to give size on every draw.\n      this.ctx.scale(BLOCK_SIZE, BLOCK_SIZE);\n    }\n    initNext() {\n      this.ctxNext = this.canvasNext.nativeElement.getContext('2d');\n      // Calculate size of canvas from constants.\n      this.ctxNext.canvas.width = 4 * BLOCK_SIZE;\n      this.ctxNext.canvas.height = 4 * BLOCK_SIZE;\n      this.ctxNext.scale(BLOCK_SIZE, BLOCK_SIZE);\n    }\n    play() {\n      this.resetGame();\n      this.next = new Piece(this.ctx);\n      this.piece = new Piece(this.ctx);\n      this.next.drawNext(this.ctxNext);\n      this.time.start = performance.now();\n      // If we have an old game running a game then cancel the old\n      if (this.requestId) {\n        cancelAnimationFrame(this.requestId);\n      }\n      this.animate();\n    }\n    resetGame() {\n      this.points = 0;\n      this.lines = 0;\n      this.level = 0;\n      this.board = this.getEmptyBoard();\n      this.time = {\n        start: 0,\n        elapsed: 0,\n        level: LEVEL[this.level]\n      };\n    }\n    animate(now = 0) {\n      this.time.elapsed = now - this.time.start;\n      if (this.time.elapsed > this.time.level) {\n        this.time.start = now;\n        if (!this.drop()) {\n          this.gameOver();\n          return;\n        }\n      }\n      this.draw();\n      this.requestId = requestAnimationFrame(this.animate.bind(this));\n    }\n    draw() {\n      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n      this.piece.draw();\n      this.drawBoard();\n    }\n    drop() {\n      let p = this.moves[KEY.DOWN](this.piece);\n      if (this.service.valid(p, this.board)) {\n        this.piece.move(p);\n      } else {\n        this.freeze();\n        this.clearLines();\n        if (this.piece.y === 0) {\n          // Game over\n          return false;\n        }\n        this.piece = this.next;\n        this.next = new Piece(this.ctx);\n        this.next.drawNext(this.ctxNext);\n      }\n      return true;\n    }\n    clearLines() {\n      let lines = 0;\n      this.board.forEach((row, y) => {\n        if (row.every(value => value !== 0)) {\n          lines++;\n          this.board.splice(y, 1);\n          this.board.unshift(Array(COLS).fill(0));\n        }\n      });\n      if (lines > 0) {\n        this.points += this.service.getLinesClearedPoints(lines, this.level);\n        this.lines += lines;\n        if (this.lines >= LINES_PER_LEVEL) {\n          this.level++;\n          this.lines -= LINES_PER_LEVEL;\n          this.time.level = LEVEL[this.level];\n        }\n      }\n    }\n    freeze() {\n      this.piece.shape.forEach((row, y) => {\n        row.forEach((value, x) => {\n          if (value > 0) {\n            this.board[y + this.piece.y][x + this.piece.x] = value;\n          }\n        });\n      });\n    }\n    drawBoard() {\n      this.board.forEach((row, y) => {\n        row.forEach((value, x) => {\n          if (value > 0) {\n            this.ctx.fillStyle = COLORS[value];\n            this.ctx.fillRect(x, y, 1, 1);\n          }\n        });\n      });\n    }\n    gameOver() {\n      cancelAnimationFrame(this.requestId);\n      this.ctx.fillStyle = 'black';\n      this.ctx.fillRect(1, 3, 8, 1.2);\n      this.ctx.font = '1px Arial';\n      this.ctx.fillStyle = 'red';\n      this.ctx.fillText('GAME OVER', 1.8, 4);\n    }\n    /*\n        Empty cell represented with 0, colours are values 1 to 7\n    */\n    getEmptyBoard() {\n      return Array.from({\n        length: ROWS\n      }, () => Array(COLS).fill(0)); // Clear board with fill(0)\n    }\n    static #_ = this.ɵfac = function BoardComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || BoardComponent)(i0.ɵɵdirectiveInject(i1.GameService));\n    };\n    static #_2 = this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: BoardComponent,\n      selectors: [[\"game-board\"]],\n      viewQuery: function BoardComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 7);\n          i0.ɵɵviewQuery(_c1, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvas = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvasNext = _t.first);\n        }\n      },\n      hostBindings: function BoardComponent_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown\", function BoardComponent_keydown_HostBindingHandler($event) {\n            return ctx.keyEvent($event);\n          }, i0.ɵɵresolveWindow);\n        }\n      },\n      decls: 18,\n      vars: 3,\n      consts: [[\"board\", \"\"], [\"next\", \"\"], [1, \"container\"], [1, \"grid\"], [1, \"game-board\"], [1, \"right-column\"], [1, \"next\"], [1, \"play-button\", 3, \"click\"]],\n      template: function BoardComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          const _r1 = i0.ɵɵgetCurrentView();\n          i0.ɵɵelementStart(0, \"div\", 2)(1, \"div\", 3);\n          i0.ɵɵelement(2, \"canvas\", 4, 0);\n          i0.ɵɵelementStart(4, \"div\", 5)(5, \"div\")(6, \"h1\");\n          i0.ɵɵtext(7, \"TETRIS\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(8, \"p\");\n          i0.ɵɵtext(9);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(10, \"p\");\n          i0.ɵɵtext(11);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(12, \"p\");\n          i0.ɵɵtext(13);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelement(14, \"canvas\", 6, 1);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(16, \"button\", 7);\n          i0.ɵɵlistener(\"click\", function BoardComponent_Template_button_click_16_listener() {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx.play());\n          });\n          i0.ɵɵtext(17, \"Play Game\");\n          i0.ɵɵelementEnd()()()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(9);\n          i0.ɵɵtextInterpolate1(\"Score: \", ctx.points);\n          i0.ɵɵadvance(2);\n          i0.ɵɵtextInterpolate1(\"Lines: \", ctx.lines);\n          i0.ɵɵadvance(2);\n          i0.ɵɵtextInterpolate1(\"Level: \", ctx.level);\n        }\n      },\n      styles: [\".container[_ngcontent-%COMP%]{box-shadow:5px 10px 18px #888;padding:15px;border-radius:15px;width:1280px;margin:0 auto;background-color:#add8e6}.grid[_ngcontent-%COMP%]{width:600px;display:grid;grid-template-columns:360px 200px;border:2px solid black;margin:0 auto;padding:10px;border-radius:15px;background-color:#ddd}.right-column[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:space-between}.game-board[_ngcontent-%COMP%]{border:2px solid grey;background-color:#fff}.play-button[_ngcontent-%COMP%]{border-radius:10px;box-shadow:5px 5px 5px #000;background-color:#4caf50;font-size:16px;padding:15px 30px;cursor:pointer}.play-button[_ngcontent-%COMP%]:hover{background-color:#00ca50}.next[_ngcontent-%COMP%]{border:1px solid grey}\"]\n    });\n  }\n  return BoardComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}